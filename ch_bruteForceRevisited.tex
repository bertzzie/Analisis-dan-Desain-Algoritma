\chapter{Brute Force}

\section{Pendahuluan}

\newthought{Brute Force} adalah sebuah sebuah pendekatan yang bersifat \textit{straight forward} untuk memecahkan suatu masalah, biasanya didasarkan pada pernyataan masalah (\textit{problem statement}) dan definisi konsep yang dilibatkan. 

Kata “force” yang digunakan dalam definisi strategi menyiratkan bahwa ia berasal dari komputer dan bukan dari intelektual seseorang. “Lakukan saja!” (\textit{just do it}) merupakan cara lain untuk menjelaskan resep pendekatan brute force. Sering kali strategi brute force menjadi yang paling mudah untuk diterapkan karena langsung dan dengan cara yang jelas (\textit{obvious way}).

Secara sederhana, brute force merupakan teknik penyelesaian masalah yang dilakukan dengan menghasilkan \textbf{semua kemungkinan solusi} yang ada dari sebuah permasalahan, dan kemudian mencoba satu per satu kemungkinan solusi tersebut sampai jawaban ditemukan. Jadi, hanya terdapat dua langkah utama dari algoritma brute force:

\begin{enumerate}
    \item Hasilkan \textbf{semua} kemungkinan solusi yang ada.
    \item Uji semua kemungkinan solusi untuk melihat apakah terdapat solusi yang benar.
\end{enumerate}

Meskipun sekilas terlihat sederhana, masing-masing langkah pada teknik brute force ini memiliki detil yang berbeda-beda. Artinya algoritma atau metode yang digunakan untuk menghasilkan semua kemungkinan solusi maupun cara pengujian kebenaran solusi akan berbeda-beda, tergantung dari permasalahan yang akan kita hadapi. Tidak jarang kita akan melihat banyak kasus di mana kedua langkah ini akhirnya memerlukan berbagai langkah (atau bahkan algoritma) tambahan.

Misalkan jika kita ingin mengetahui apakah sebuah bilangan merupakan bilangan prima atau bukan, kita dapat langsung membagikan semua bilangan dari $2$ sampai $n$ untuk melihat apakah terdapat bilangan yang dapat habis membagi $n$. Salah satu cara untuk mencapai hal ini dapat dilihat pada Algoritma~\ref{algo:prime}.

\marginnote[-4cm]{
    \begin{teori}
        Definisi dari bilangan prima yaitu bilangan alami $> 1$ yang tidak memiliki pembagi selain $1$ dan dirinya sendiri.
    \end{teori}
}

\lstinputlisting[language=Python, 
                 label={algo:prime},
                 float,
                 caption=Algoritma Cek Bilangan Prima dengan Brute Force
                ]
                {code/5-prime.py}

\FloatBarrier

Pada Algoritma~\ref{algo:prime}, kita dapat melihat langkah-langkah brute force sebagai berikut:

\begin{enumerate}
    \item Penggunaan perulangan for (pada baris 3) untuk menghasilkan semua kemungkinan bilangan dari $2$ sampai $n$.
    \item Pengujian solusi dilakukan dengan menggunakan percabangan sederhana pada baris 4. Jika terdapat salah satu bilangan dari $2$ sampai $n$ yang habis dibagi $n$, maka $n$ bukan prima.
\end{enumerate}

\marginnote[-4cm]{
    \begin{latihan}
        Hitung kompleksitas dari Algoritma~\ref{algo:prime}.
    \end{latihan}
}

Pada kasus bilangan prima ini kita dapat melihat bagaimana langkah menghasilkan semua kemungkinan solusi tidak secara langsung menghasilkan jawaban (karena solusi dari permasalahan hanya dua: benar atau salah; \textit{true} atau \textit{false}). Yang kita hasilkan dalam hal ini adalah nilai-nilai yang nantinya akan diuji oleh tahap selanjutnya. Kita akan melihat berbagai cara lain untuk menghasilkan semua kemungkinan dan pengujian jawaban seperti ini lagi nantinya.

Karena sifat dari brute force yang mencoba menemukan seluruh kemungkinan solusi satu per satu ini, biasanya algoritma brute force selalu berhasil mendapatkan jawaban, jika memang terdapat jawaban pada permasalahan yang akan diselesaikan. Sayangnya, juga karena sifat mencoba semua kemungkinan ini juga maka jumlah langkah yang diperlukan untuk menyelesaikan sebuah masalah dengan brute force selalu berbanding lurus dengan ukuran permasalahan yang akan diselesaikan. Semakin besar masalah, semakin lambat brute force menyelesaikan masalah tersebut. 

Berdasarkan sifat lambat-tapi-pasti-selesai ini brute force biasanya digunakan pada dua situasi:

\begin{enumerate}
    \item Ketika ukuran permasalahan kecil
    \item Ketika terdapat metode khusus (misalnya: heuristik) untuk menghasilkan ukuran kemungkinan solusi yang kecil
    \item Ketika kemudahan atau kesederhanaan implementasi lebih penting daripada kecepatan penyeleasian
\end{enumerate}

\section{Contoh Kasus: Perkalian Matriks}

Algoritma: hitung setiap elemen hasil perkalian satu per satu, dengan cara mengalikan dua vektor yang panjangnya n. Misalkan $C = A \times B$ dan elemen-elemen matrik dinyatakan sebagai $c_{ij}$, $a_{ij}$, dan $b_{ij}$.

\begin{equation}\label{eq:matriks-perkalian}
    \begin{aligned}
        c_{ij} & = a_{i1}b_{1j} + a_{i2}b_{2j} + \cdots + a_{in}b_{nj} \\
               & = \sum\limits_{k = 1}^n c_{ik}c_{kj}
    \end{aligned}
\end{equation}

Pseudocode:

\lstinputlisting[language=Python, 
                 label={algo:matrix-perkalian},
                 linebackgroundcolor={\ifnum\value{lstnumber}=11\color{codehighlight}\fi},
                 caption=Algoritma Perkalian Matriks
                ]
                {code/6-perkalian-matriks.py}

Menghitung kompleksitas:

Operasi dasar untuk algoritma di atas adalah perkalian dan penjumlahan yang ada di baris 11 (yang diberi warna pada Algoritma~\ref{algo:matrix-perkalian}).

Rumus matematis untuk menghitung kompleksitasnya adalah:

\begin{equation}\label{eq:matriks-perkalian-kompleksitas}
    \begin{aligned}
        T(n) & = \sum\limits_{i=0}^{n-1} \sum\limits_{j=0}^{n-1} \sum\limits_{k=0}^{n-1} 1 \\
             & = \sum\limits_{i=0}^{n-1} \sum\limits_{j=0}^{n-1} n \\
             & = \sum\limits_{i=0}^{n-1} n \times n \\
             & = n \times n \times n \\
             & = n^3
    \end{aligned}
\end{equation}

Dalam notasi asimtotik menjadi:

\begin{equation}\label{eq:matriks-perkalian-kompleksitas-final}
    T(n) = O(n^3)
\end{equation}

\section{Contoh Kasus: Selection Sort}

Algoritma ini mengurutkan deret dengan mencari elemen terkecil pada seluruh elemen dan menukarnya dengan posisi pertama (indeks 0). Kemudian dilakukan lagi hal yang sama untuk mencari elemen terkecil kedua untuk ditempatkan pada posisi kedua (indeks 1), dan seterusnya.

Pendekatan ini merupakan salah satu wujud brute-force yang sangat jelas.

Pseudocode:

\lstinputlisting[language=Python, 
                 label={algo:selection-sort},
                 linebackgroundcolor={\ifnum\value{lstnumber}=7\color{codehighlight}\fi},
                 caption=Algoritma Selection Sort,
                ]
                {code/7-selection-sort.py}

Menghitung kompleksitas

Operasi dasar untuk algoritma tersebut adalah perbandingan yang terdapat pada baris 7 pada Algoritma~\ref{algo:selection-sort}.

Pada algoritma ini, kasus terburuk maupun terbaiknya memiliki kompleksitas yang sama, karena operasi dasar akan terus berjalan sama pada segala kondisi.

Rumus matematis untuk menghitung kompleksitasnya adalah:

\begin{equation}\label{eq:selection-kompleksitas}
    \begin{aligned}
        T(n) & = \sum\limits_{i=0}^{n-2} \sum\limits_{j=i+1}^{n-1} 1 \\
             & = \sum\limits_{i=0}^{n-2} [(n - 1) - (i + 1) + 1] \\
             & = \sum\limits_{i=0}^{n-2} (n - 1 - i) \\
             & = \sum\limits_{i=0}^{n-2} (n - 1) - \sum\limits_{i=0}^{n-2} i \\
             & = (n - 1) \sum\limits_{i=0}^{n-2} 1 - \sum\limits_{i=0}^{n-2} i \\
             & = (n - 1)(n - 1) - \sum\limits_{i=0}^{n-2} i \\
             & = (n - 1)(n - 1) - \frac{(n - 2)(n - 1)}{2} \\
             & = \frac{2(n - 1)(n - 1) - (n - 2)(n - 1)}{2} \\
             & = \frac{n(n - 1)}{2} \\
    \end{aligned}
\end{equation}

Dalam notasi asimtotik menjadi:

\begin{equation}\label{eq:selection-kompleksitas-final}
    T(n) = O(n^2)
\end{equation}

\section{Contoh Kasus: Permutasi String}
